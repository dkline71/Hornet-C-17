// AUTOGENERATED, DO NOT MODIFY

#include "instr_encoding.hpp"
#define __INSTR_ENCODING_HPP__

const instr_code_info ic_infos[] = {
    { "abs.d", IF_FP2, "Floating Point Absolute Value" },
    { "abs.ps", IF_FP2, "Floating Point Absolute Value" },
    { "abs.s", IF_FP2, "Floating Point Absolute Value" },
    { "add", IF_R3, "Add Word" },
    { "addi", IF_IMM3, "Add Immediate Word" },
    { "addiu", IF_IMM3, "Add Immediate Unsigned Word" },
    { "addu", IF_R3, "Add Unsigned Word" },
    { "add.d", IF_FP2, "Floating Point Add" },
    { "add.ps", IF_FP2, "Floating Point Add" },
    { "add.s", IF_FP2, "Floating Point Add" },
    { "alnv.ps", IF_FP4G, "Floating Point Align Variable" },
    { "and", IF_R3, "And" },
    { "andi", IF_IMM3, "And Immediate" },
    { "b", IF_B1, "Unconditional Branch" },
    { "bal", IF_B1, "Branch and Link" },
    { "bc1f", IF_BC, "Branch on FP False" },
    { "bc1fl", IF_BC, "Branch on FP False Likely" },
    { "bc1t", IF_BC, "Branch on FP True" },
    { "bc1tl", IF_BC, "Branch on FP True Likely" },
    { "bc2f", IF_BC, "Branch on COP2 False" },
    { "bc2fl", IF_BC, "Branch on COP2 False Likely" },
    { "bc2t", IF_BC, "Branch on COP2 True" },
    { "bc2tl", IF_BC, "Branch on COP2 True Likely" },
    { "beq", IF_B3, "Branch on Equal" },
    { "beql", IF_B3, "Branch on Equal Likely" },
    { "bgez", IF_B2, "Branch on Greater Than or Equal to Zero" },
    { "bgezal", IF_B2, "Branch on Greater Than or Equal to Zero and Link" },
    { "bgezall", IF_B2, "Branch on Greater Than or Equal to Zero and Link Likely" },
    { "bgezl", IF_B2, "Branch on Greater Than or Equal to Zero Likely" },
    { "bgtz", IF_B2, "Branch on Greater Than Zero" },
    { "bgtzl", IF_B2, "Branch on Greater Than Zero Likely" },
    { "blez", IF_B2, "Branch on Less Than or Equal to Zero" },
    { "blezl", IF_B2, "Branch on Less Than or Equal to Zero Likely" },
    { "bltz", IF_B2, "Branch on Less Than Zero" },
    { "bltzal", IF_B2, "Branch on Less Than Zero and Link" },
    { "bltzall", IF_B2, "Branch on Less Than Zero and Link Likely" },
    { "bltzl", IF_B2, "Branch on Less Than Zero Likely" },
    { "bne", IF_B3, "Branch on Not Equal" },
    { "bnel", IF_B3, "Branch on Not Equal Likely" },
    { "break", IF_NOARG, "Breakpoint" },
    { "cache", IF_CACHE, "Perform Cache Operation" },
    { "ceil.l.d", IF_FP2, "Floating Point Ceiling Convert to Long Fixed Point" },
    { "ceil.l.s", IF_FP2, "Floating Point Ceiling Convert to Long Fixed Point" },
    { "ceil.w.d", IF_FP2, "Floating Point Ceiling Convert to Word Fixed Point" },
    { "ceil.w.s", IF_FP2, "Floating Point Ceiling Convert to Word Fixed Point" },
    { "cfc1", IF_FPMV, "Move Control Word from Floating Point" },
    { "cfc2", IF_C2MV, "Move Control Word from Coprocessor 2" },
    { "clo", IF_COUNT, "Count Leading Ones in Word" },
    { "clz", IF_COUNT, "Count Leading Zeros in Word" },
    { "cop2", IF_C2OP, "Coprocessor Operation to Coprocessor 2" },
    { "ctc1", IF_FPMV, "Move Control Word to Floating Point" },
    { "ctc2", IF_C2MV, "Move Control Word to Coprocessor 2" },
    { "cvt.d.l", IF_FP2, "Floating Point Convert to Double Floating Point" },
    { "cvt.d.s", IF_FP2, "Floating Point Convert to Double Floating Point" },
    { "cvt.d.w", IF_FP2, "Floating Point Convert to Double Floating Point" },
    { "cvt.l.d", IF_FP2, "Floating Point Convert to Long Fixed Point" },
    { "cvt.l.s", IF_FP2, "Floating Point Convert to Long Fixed Point" },
    { "cvt.ps.s", IF_FP3, "Floating Point Convert Pair to Paired Single" },
    { "cvt.s.d", IF_FP2, "Floating Point Convert to Single Floating Point" },
    { "cvt.s.l", IF_FP2, "Floating Point Convert to Single Floating Point" },
    { "cvt.s.pl", IF_FP2, "Floating Point Convert Pair Lower to Single Floating Point" },
    { "cvt.s.pu", IF_FP2, "Floating Point Convert Pair Upper to Single Floating Point" },
    { "cvt.s.w", IF_FP2, "Floating Point Convert to Single Floating Point" },
    { "cvt.w.d", IF_FP2, "Floating Point Convert to Word Fixed Point" },
    { "cvt.w.s", IF_FP2, "Floating Point Convert to Word Fixed Point" },
    { "c.eq.d", IF_FPC, "Floating Point Compare" },
    { "c.eq.ps", IF_FPC, "Floating Point Compare" },
    { "c.eq.s", IF_FPC, "Floating Point Compare" },
    { "c.f.d", IF_FPC, "Floating Point Compare" },
    { "c.f.ps", IF_FPC, "Floating Point Compare" },
    { "c.f.s", IF_FPC, "Floating Point Compare" },
    { "c.le.d", IF_FPC, "Floating Point Compare" },
    { "c.le.ps", IF_FPC, "Floating Point Compare" },
    { "c.le.s", IF_FPC, "Floating Point Compare" },
    { "c.lt.d", IF_FPC, "Floating Point Compare" },
    { "c.lt.ps", IF_FPC, "Floating Point Compare" },
    { "c.lt.s", IF_FPC, "Floating Point Compare" },
    { "c.nge.d", IF_FPC, "Floating Point Compare" },
    { "c.nge.ps", IF_FPC, "Floating Point Compare" },
    { "c.nge.s", IF_FPC, "Floating Point Compare" },
    { "c.ngle.d", IF_FPC, "Floating Point Compare" },
    { "c.ngle.ps", IF_FPC, "Floating Point Compare" },
    { "c.ngle.s", IF_FPC, "Floating Point Compare" },
    { "c.ngl.d", IF_FPC, "Floating Point Compare" },
    { "c.ngl.ps", IF_FPC, "Floating Point Compare" },
    { "c.ngl.s", IF_FPC, "Floating Point Compare" },
    { "c.ngt.d", IF_FPC, "Floating Point Compare" },
    { "c.ngt.ps", IF_FPC, "Floating Point Compare" },
    { "c.ngt.s", IF_FPC, "Floating Point Compare" },
    { "c.ole.d", IF_FPC, "Floating Point Compare" },
    { "c.ole.ps", IF_FPC, "Floating Point Compare" },
    { "c.ole.s", IF_FPC, "Floating Point Compare" },
    { "c.olt.d", IF_FPC, "Floating Point Compare" },
    { "c.olt.ps", IF_FPC, "Floating Point Compare" },
    { "c.olt.s", IF_FPC, "Floating Point Compare" },
    { "c.seq.d", IF_FPC, "Floating Point Compare" },
    { "c.seq.ps", IF_FPC, "Floating Point Compare" },
    { "c.seq.s", IF_FPC, "Floating Point Compare" },
    { "c.sf.d", IF_FPC, "Floating Point Compare" },
    { "c.sf.ps", IF_FPC, "Floating Point Compare" },
    { "c.sf.s", IF_FPC, "Floating Point Compare" },
    { "c.ueq.d", IF_FPC, "Floating Point Compare" },
    { "c.ueq.ps", IF_FPC, "Floating Point Compare" },
    { "c.ueq.s", IF_FPC, "Floating Point Compare" },
    { "c.ule.d", IF_FPC, "Floating Point Compare" },
    { "c.ule.ps", IF_FPC, "Floating Point Compare" },
    { "c.ule.s", IF_FPC, "Floating Point Compare" },
    { "c.ult.d", IF_FPC, "Floating Point Compare" },
    { "c.ult.ps", IF_FPC, "Floating Point Compare" },
    { "c.ult.s", IF_FPC, "Floating Point Compare" },
    { "c.un.d", IF_FPC, "Floating Point Compare" },
    { "c.un.ps", IF_FPC, "Floating Point Compare" },
    { "c.un.s", IF_FPC, "Floating Point Compare" },
    { "deret", IF_NOARG, "Debug Exception Return" },
    { "di", IF_INT, "Disable Interrupts" },
    { "div", IF_R2_, "Divide Word" },
    { "divu", IF_R2_, "Divide Unsigned Word" },
    { "div.d", IF_FP3, "Floating Point Divide" },
    { "div.s", IF_FP3, "Floating Point Divide" },
    { "ehb", IF_NOARG, "Execution Hazard Barrier" },
    { "ei", IF_INT, "Enable Interrupts" },
    { "eret", IF_NOARG, "Exception Return" },
    { "ext", IF_EXT, "Extract Bit Field" },
    { "floor.l.d", IF_FP2, "Floating Point Floor Convert to Long Fixed Point" },
    { "floor.l.s", IF_FP2, "Floating Point Floor Convert to Long Fixed Point" },
    { "floor.w.d", IF_FP2, "Floating Point Floor Convert to Word Fixed Point" },
    { "floor.w.s", IF_FP2, "Floating Point Floor Convert to Word Fixed Point" },
    { "ins", IF_INS, "Insert Bit Field" },
    { "j", IF_J, "Jump" },
    { "jal", IF_J, "Jump and Link" },
    { "jalr", IF_JALR, "Jump and Link Register" },
    { "jalr.hb", IF_JALR, "Jump and Link Register with Hazard Barrier" },
    { "jr", IF_R2_, "Jump Register" },
    { "jr.hb", IF_R2_, "Jump Register with Hazard Barrier" },
    { "lb", IF_MEM, "Load Byte" },
    { "lbu", IF_MEM, "Load Byte Unsigned" },
    { "ldc1", IF_FPMEM, "Load Doubleword to Floating Point" },
    { "ldc2", IF_C2MEM, "Load Doubleword to Coprocessor 2" },
    { "ldxc1", IF_FPLDX, "Load Doubleword Indexed to Floating Point" },
    { "lh", IF_MEM, "Load Halfword" },
    { "lhu", IF_MEM, "Load Halfword Unsigned" },
    { "ll", IF_MEM, "Load Linked Word" },
    { "lui", IF_IMM2, "Load Upper Immediate" },
    { "luxc1", IF_FPLDX, "Load Doubleword Indexed Unaligned to Floating Point" },
    { "lw", IF_MEM, "Load Word" },
    { "lwc1", IF_FPMEM, "Load Word to Floating Point" },
    { "lwc2", IF_C2MEM, "Load Word to Coprocessor 2" },
    { "lwl", IF_MEM, "Load Word Left" },
    { "lwr", IF_MEM, "Load Word Right" },
    { "lwxc1", IF_FPLDX, "Load Word Indexed to Floating Point" },
    { "madd", IF_R2_, "Multiply and Add Word to Hi, Lo" },
    { "maddu", IF_R2_, "Multiply and Add Unsigned Word to Hi, Lo" },
    { "madd.d", IF_FP4, "Floating Point Multiply Add" },
    { "madd.ps", IF_FP4, "Floating Point Multiply Add" },
    { "madd.s", IF_FP4, "Floating Point Multiply Add" },
    { "mfc0", IF_C0MV, "Move from Coprocessor 0" },
    { "mfc1", IF_FPMV, "Move Word from Floating Point" },
    { "mfc2", IF_C2MV, "Move Word from Coprocessor 2" },
    { "mfhc1", IF_FPMV, "Move Word from High Half of Floating Point Register" },
    { "mfhc2", IF_C2MV, "Move Word from High Half of Coprocessor 2 Register" },
    { "mfhi", IF_R1, "Move From HI Register" },
    { "mflo", IF_R1, "Move From LO Register" },
    { "move", IF_R2Z, "Copy Register" },
    { "movf", IF_MVCFP, "Move Conditional on Floating Point False" },
    { "movf.d", IF_FPMVCFP, "Floating Point Move Conditional on Floating Point False" },
    { "movf.ps", IF_FPMVCFP, "Floating Point Move Conditional on Floating Point False" },
    { "movf.s", IF_FPMVCFP, "Floating Point Move Conditional on Floating Point False" },
    { "movn", IF_R3, "Move Conditional on Not Zero" },
    { "movn.d", IF_FPMVC, "Floating Point Move Conditional on Not Zero" },
    { "movn.ps", IF_FPMVC, "Floating Point Move Conditional on Not Zero" },
    { "movn.s", IF_FPMVC, "Floating Point Move Conditional on Not Zero" },
    { "movt", IF_MVCFP, "Move Conditional on Floating Point True" },
    { "movt.d", IF_FPMVCFP, "Floating Point Move Conditional on Floating Point True" },
    { "movt.ps", IF_FPMVCFP, "Floating Point Move Conditional on Floating Point True" },
    { "movt.s", IF_FPMVCFP, "Floating Point Move Conditional on Floating Point True" },
    { "movz", IF_R3, "Move Conditional on Zero" },
    { "movz.d", IF_FPMVC, "Floating Point Move Conditional on Zero" },
    { "movz.ps", IF_FPMVC, "Floating Point Move Conditional on Zero" },
    { "movz.s", IF_FPMVC, "Floating Point Move Conditional on Zero" },
    { "mov.d", IF_FP2, "Floating Point Move" },
    { "mov.ps", IF_FP2, "Floating Point Move" },
    { "mov.s", IF_FP2, "Floating Point Move" },
    { "msub", IF_R2_, "Multiply and Subtract Word to Hi, Lo" },
    { "msubu", IF_R2_, "Multiply and Subtract Unsigned Word to Hi, Lo" },
    { "msub.d", IF_FP4, "Floating Point Multiply Subtract" },
    { "msub.ps", IF_FP4, "Floating Point Multiply Subtract" },
    { "msub.s", IF_FP4, "Floating Point Multiply Subtract" },
    { "mtc0", IF_C0MV, "Move to Coprocessor 0" },
    { "mtc1", IF_FPMV, "Move Word to Floating Point" },
    { "mtc2", IF_C2MV, "Move Word to Coprocessor 2" },
    { "mthc1", IF_FPMV, "Move Word to High Half of Floating Point Register" },
    { "mthc2", IF_C2MV, "Move Word to High Half of Coprocessor 2 Register" },
    { "mthi", IF_R1, "Move To HI Register" },
    { "mtlo", IF_R1, "Move To LO Register" },
    { "mul", IF_R3, "Multiply Word to GPR" },
    { "mult", IF_R2_, "Multiply Word" },
    { "multu", IF_R2_, "Multiply Unsigned Word" },
    { "mul.d", IF_FP3, "Floating Point Multiply" },
    { "mul.ps", IF_FP3, "Floating Point Multiply" },
    { "mul.s", IF_FP3, "Floating Point Multiply" },
    { "neg.d", IF_FP2, "Floating Point Negate" },
    { "neg.ps", IF_FP2, "Floating Point Negate" },
    { "neg.s", IF_FP2, "Floating Point Negate" },
    { "nmadd.d", IF_FP4, "Floating Point Negative Multiply Add" },
    { "nmadd.ps", IF_FP4, "Floating Point Negative Multiply Add" },
    { "nmadd.s", IF_FP4, "Floating Point Negative Multiply Add" },
    { "nmsub.d", IF_FP4, "Floating Point Negative Multiply Subtract" },
    { "nmsub.ps", IF_FP4, "Floating Point Negative Multiply Subtract" },
    { "nmsub.s", IF_FP4, "Floating Point Negative Multiply Subtract" },
    { "nop", IF_NOARG, "No Operation" },
    { "nor", IF_R3, "Not Or" },
    { "or", IF_R3, "Or" },
    { "ori", IF_IMM3, "Or Immediate" },
    { "pause", IF_NOARG, "Wait for LLBit to Clear Release 2.1 Only" },
    { "pll.ps", IF_FP3, "Pair Lower Lower" },
    { "plu.ps", IF_FP3, "Pair Lower Upper" },
    { "pref", IF_CACHE, "Prefetch" },
    { "prefx", IF_CACHEX, "Prefetch Indexed" },
    { "pul.ps", IF_FP3, "Pair Upper Lower" },
    { "puu.ps", IF_FP3, "Pair Upper Upper" },
    { "rdhwr", IF_RDHW, "Read Hardware Register" },
    { "rdpgpr", IF_R2, "Read GPR from Previous Shadow Set" },
    { "recip.d", IF_FP2, "Reciprocal Approximation" },
    { "recip.s", IF_FP2, "Reciprocal Approximation" },
    { "rotr", IF_SH, "Rotate Word Right" },
    { "rotrv", IF_SHV, "Rotate Word Right Variable" },
    { "round.l.d", IF_FP2, "Floating Point Round to Long Fixed Point" },
    { "round.l.s", IF_FP2, "Floating Point Round to Long Fixed Point" },
    { "round.w.d", IF_FP2, "Floating Point Round to Word Fixed Point" },
    { "round.w.s", IF_FP2, "Floating Point Round to Word Fixed Point" },
    { "rsqrt.d", IF_FP2, "Reciprocal Square Root Approximation" },
    { "rsqrt.s", IF_FP2, "Reciprocal Square Root Approximation" },
    { "sb", IF_MEM, "Store Byte" },
    { "sc", IF_MEM, "Store Conditional Word" },
    { "sdbbp", IF_NOARG, "Software Debug Breakpoint" },
    { "sdc1", IF_FPMEM, "Store Doubleword from Floating Point" },
    { "sdc2", IF_C2MEM, "Store Doubleword from Coprocessor 2" },
    { "sdxc1", IF_FPSTX, "Store Doubleword Indexed from Floating Point" },
    { "seb", IF_R2, "Sign-Extend Byte" },
    { "seh", IF_R2, "Sign-Extend Halftword" },
    { "sh", IF_MEM, "Store Halfword" },
    { "sll", IF_SH, "Shift Word Left Logical" },
    { "sllv", IF_SHV, "Shift Word Left Logical Variable" },
    { "slt", IF_R3, "Set on Less Than" },
    { "slti", IF_IMM3, "Set on Less Than Immediate" },
    { "sltiu", IF_IMM3, "Set on Less Than Immediate Unsigned" },
    { "sltu", IF_R3, "Set on Less Than Unsigned" },
    { "sqrt.d", IF_FP2, "Floating Point Square Root" },
    { "sqrt.s", IF_FP2, "Floating Point Square Root" },
    { "sra", IF_SH, "Shift Word Right Arithmetic" },
    { "srav", IF_SHV, "Shift Word Right Arithmetic Variable" },
    { "srl", IF_SH, "Shift Word Right Logical" },
    { "srlv", IF_SHV, "Shift Word Right Logical Variable" },
    { "ssnop", IF_NOARG, "Superscalar No Operation" },
    { "sub", IF_R3, "Subtract Word" },
    { "subu", IF_R3, "Subtract Unsigned Word" },
    { "sub.d", IF_FP3, "Floating Point Subtract" },
    { "sub.ps", IF_FP3, "Floating Point Subtract" },
    { "sub.s", IF_FP3, "Floating Point Subtract" },
    { "suxc1", IF_FPSTX, "Store Doubleword Indexed Unaligned from Floating Point" },
    { "sw", IF_MEM, "Store Word" },
    { "swc1", IF_FPMEM, "Store Word from Floating Point" },
    { "swc2", IF_C2MEM, "Store Word from Coprocessor 2" },
    { "swl", IF_MEM, "Store Word Left" },
    { "swr", IF_MEM, "Store Word Right" },
    { "swxc1", IF_FPSTX, "Store Word Indexed from Floating Point" },
    { "sync", IF_SYNC, "Synchronize Shared Memory" },
    { "synci", IF_MEM_, "Synchronize Caches to Make Instruction Writes Effective" },
    { "syscall", IF_NOARG, "System Call" },
    { "teq", IF_R2_, "Trap if Equal" },
    { "teqi", IF_IMM2_, "Trap if Equal Immediate" },
    { "tge", IF_R2_, "Trap if Greater or Equal" },
    { "tgei", IF_IMM2_, "Trap if Greater of Equal Immediate" },
    { "tgeiu", IF_IMM2_, "Trap if Greater or Equal Immediate Unsigned" },
    { "tgeu", IF_R2_, "Trap if Greater or Equal Unsigned" },
    { "tlbp", IF_NOARG, "Probe TLB for Matching Entry" },
    { "tlbr", IF_NOARG, "Read Indexed TLB Entry" },
    { "tlbwi", IF_NOARG, "Write Indexed TLB Entry" },
    { "tlbwr", IF_NOARG, "Write Random TLB Entry" },
    { "tlt", IF_R2_, "Trap if Less Than" },
    { "tlti", IF_IMM2_, "Trap if Less Than Immediate" },
    { "tltiu", IF_IMM2_, "Trap if Less Than Immediate Unsigned" },
    { "tltu", IF_R2_, "Trap if Less Than Unsigned" },
    { "tne", IF_R2_, "Trap if Not Equal" },
    { "tnei", IF_IMM2_, "Trap if Not Equal Immediate" },
    { "trunc.l.d", IF_FP2, "Floating Point Truncate to Long Fixed Point" },
    { "trunc.l.s", IF_FP2, "Floating Point Truncate to Long Fixed Point" },
    { "trunc.w.d", IF_FP2, "Floating Point Truncate to Word Fixed Point" },
    { "trunc.w.s", IF_FP2, "Floating Point Truncate to Word Fixed Point" },
    { "wait", IF_NOARG, "Enter Standby Mode" },
    { "wrpgpr", IF_R2, "Write GPR to Previous Shadow Set" },
    { "wsbh", IF_R2, "Word Swap Bytes Within Halfwords" },
    { "xor", IF_R3, "Exclusive Or" },
    { "xori", IF_IMM3, "Exclusive Or Immediate" }
};

